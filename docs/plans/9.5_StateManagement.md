# Plan 9.5: State Management with Zustand

## Summary

Set up Zustand stores for all application features including authentication, user data, steps tracking, friends management, groups, and notifications. Create API service wrappers that integrate with Zustand stores for clean separation of concerns.

## Affected Feature Slices

- **Frontend/Store**: All Zustand stores
- **Frontend/Services/API**: API service wrappers

## Prerequisites

- Plan 9.1: Expo Project Initialization
- Plan 9.3: Supabase Client Configuration

## State Architecture

```
Global State (Zustand)
├── authStore      - Authentication state and methods
├── userStore      - Current user profile and preferences
├── stepsStore     - Step tracking and history
├── friendsStore   - Friends list and requests
├── groupsStore    - Groups and leaderboards
└── notificationsStore - In-app notifications
```

## Implementation Steps

### 1. Install Dependencies

```bash
cd Stepper.Mobile

# State management
npm install zustand

# For persistence
npm install zustand/middleware
```

### 2. Create Base Store Types

Create `src/types/store.ts`:

```typescript
export interface LoadingState {
  isLoading: boolean;
  error: string | null;
}

export interface PaginatedState<T> {
  items: T[];
  hasMore: boolean;
  page: number;
}

export type AsyncAction<T extends any[], R> = (
  ...args: T
) => Promise<R>;
```

### 3. Create Auth Store

Create `src/store/authStore.ts`:

```typescript
import { create } from 'zustand';
import { Session, User } from '@supabase/supabase-js';
import {
  signInWithEmail,
  signUpWithEmail,
  signOut as supabaseSignOut,
  resetPassword,
} from '@services/supabase';

interface AuthState {
  session: Session | null;
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;

  // Actions
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, displayName: string) => Promise<void>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  setSession: (session: Session | null) => void;
  clearError: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  session: null,
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null,

  signIn: async (email, password) => {
    set({ isLoading: true, error: null });
    try {
      const { session, user } = await signInWithEmail(email, password);
      set({
        session,
        user,
        isAuthenticated: true,
        isLoading: false,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  signUp: async (email, password, displayName) => {
    set({ isLoading: true, error: null });
    try {
      const { session, user } = await signUpWithEmail(email, password, displayName);
      set({
        session,
        user,
        isAuthenticated: !!session,
        isLoading: false,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  signOut: async () => {
    set({ isLoading: true, error: null });
    try {
      await supabaseSignOut();
      set({
        session: null,
        user: null,
        isAuthenticated: false,
        isLoading: false,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
    }
  },

  resetPassword: async (email) => {
    set({ isLoading: true, error: null });
    try {
      await resetPassword(email);
      set({ isLoading: false });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  setSession: (session) => {
    set({
      session,
      user: session?.user ?? null,
      isAuthenticated: !!session,
    });
  },

  clearError: () => set({ error: null }),
}));
```

### 4. Create User Store

Create `src/store/userStore.ts`:

```typescript
import { create } from 'zustand';
import { usersApi } from '@services/api/usersApi';

export interface UserProfile {
  id: string;
  email: string;
  display_name: string;
  username: string;
  bio?: string;
  location?: string;
  avatar_url?: string;
  preferences: UserPreferences;
  created_at: string;
}

export interface UserPreferences {
  units: 'metric' | 'imperial';
  daily_step_goal: number;
  theme: 'light' | 'dark' | 'system';
  notifications: NotificationPreferences;
  privacy: PrivacySettings;
}

interface NotificationPreferences {
  push_enabled: boolean;
  friend_requests: boolean;
  friend_accepted: boolean;
  group_invites: boolean;
  goal_achieved: boolean;
}

interface PrivacySettings {
  profile_visibility: 'public' | 'friends' | 'private';
  activity_visibility: 'public' | 'friends' | 'private';
  find_me: 'everyone' | 'friends' | 'nobody';
}

interface UserState {
  currentUser: UserProfile | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchCurrentUser: () => Promise<void>;
  updateProfile: (updates: Partial<UserProfile>) => Promise<void>;
  updatePreferences: (prefs: Partial<UserPreferences>) => Promise<void>;
  uploadAvatar: (uri: string) => Promise<void>;
}

export const useUserStore = create<UserState>((set, get) => ({
  currentUser: null,
  isLoading: false,
  error: null,

  fetchCurrentUser: async () => {
    set({ isLoading: true, error: null });
    try {
      const user = await usersApi.getCurrentUser();
      set({ currentUser: user, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  updateProfile: async (updates) => {
    set({ isLoading: true, error: null });
    try {
      const updated = await usersApi.updateProfile(updates);
      set({ currentUser: updated, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  updatePreferences: async (prefs) => {
    set({ isLoading: true, error: null });
    try {
      const current = get().currentUser;
      if (!current) throw new Error('No user loaded');
      
      const updated = await usersApi.updatePreferences(prefs);
      set({
        currentUser: { ...current, preferences: updated },
        isLoading: false,
      });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  uploadAvatar: async (uri) => {
    set({ isLoading: true, error: null });
    try {
      const avatarUrl = await usersApi.uploadAvatar(uri);
      const current = get().currentUser;
      if (current) {
        set({
          currentUser: { ...current, avatar_url: avatarUrl },
          isLoading: false,
        });
      }
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },
}));
```

### 5. Create Steps Store

Create `src/store/stepsStore.ts`:

```typescript
import { create } from 'zustand';
import { stepsApi } from '@services/api/stepsApi';

export interface StepEntry {
  id: string;
  user_id: string;
  date: string;
  steps: number;
  distance_meters: number;
  created_at: string;
}

export interface StepStats {
  today: number;
  week: number;
  month: number;
  average: number;
  streak: number;
}

interface StepsState {
  todaySteps: number;
  stats: StepStats | null;
  history: StepEntry[];
  isLoading: boolean;
  error: string | null;

  // Actions
  addSteps: (steps: number, distanceMeters: number) => Promise<void>;
  fetchTodaySteps: () => Promise<void>;
  fetchStats: () => Promise<void>;
  fetchHistory: (period: 'daily' | 'weekly' | 'monthly') => Promise<void>;
}

export const useStepsStore = create<StepsState>((set) => ({
  todaySteps: 0,
  stats: null,
  history: [],
  isLoading: false,
  error: null,

  addSteps: async (steps, distanceMeters) => {
    set({ isLoading: true, error: null });
    try {
      await stepsApi.addSteps(steps, distanceMeters);
      const today = await stepsApi.getTodaySteps();
      set({ todaySteps: today.steps, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  fetchTodaySteps: async () => {
    set({ isLoading: true, error: null });
    try {
      const today = await stepsApi.getTodaySteps();
      set({ todaySteps: today.steps, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchStats: async () => {
    set({ isLoading: true, error: null });
    try {
      const stats = await stepsApi.getStats();
      set({ stats, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchHistory: async (period) => {
    set({ isLoading: true, error: null });
    try {
      const history = await stepsApi.getHistory(period);
      set({ history, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },
}));
```

### 6. Create Friends Store

Create `src/store/friendsStore.ts`:

```typescript
import { create } from 'zustand';
import { friendsApi } from '@services/api/friendsApi';

export interface Friend {
  id: string;
  user_id: string;
  display_name: string;
  username: string;
  avatar_url?: string;
  today_steps?: number;
  status: 'pending' | 'accepted';
}

interface FriendsState {
  friends: Friend[];
  requests: Friend[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchFriends: () => Promise<void>;
  fetchRequests: () => Promise<void>;
  sendRequest: (userId: string) => Promise<void>;
  acceptRequest: (userId: string) => Promise<void>;
  declineRequest: (userId: string) => Promise<void>;
  removeFriend: (userId: string) => Promise<void>;
}

export const useFriendsStore = create<FriendsState>((set, get) => ({
  friends: [],
  requests: [],
  isLoading: false,
  error: null,

  fetchFriends: async () => {
    set({ isLoading: true, error: null });
    try {
      const friends = await friendsApi.getFriends();
      set({ friends, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchRequests: async () => {
    set({ isLoading: true, error: null });
    try {
      const requests = await friendsApi.getRequests();
      set({ requests, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  sendRequest: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      await friendsApi.sendRequest(userId);
      set({ isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  acceptRequest: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      await friendsApi.acceptRequest(userId);
      const requests = get().requests.filter(r => r.user_id !== userId);
      set({ requests, isLoading: false });
      await get().fetchFriends();
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  declineRequest: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      await friendsApi.declineRequest(userId);
      const requests = get().requests.filter(r => r.user_id !== userId);
      set({ requests, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  removeFriend: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      await friendsApi.removeFriend(userId);
      const friends = get().friends.filter(f => f.user_id !== userId);
      set({ friends, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },
}));
```

### 7. Create Groups Store

Create `src/store/groupsStore.ts`:

```typescript
import { create } from 'zustand';
import { groupsApi } from '@services/api/groupsApi';

export interface Group {
  id: string;
  name: string;
  description?: string;
  competition_type: 'daily' | 'weekly' | 'monthly';
  is_private: boolean;
  member_count: number;
  created_at: string;
}

export interface GroupMember {
  user_id: string;
  display_name: string;
  username: string;
  avatar_url?: string;
  steps: number;
  rank: number;
}

interface GroupsState {
  groups: Group[];
  currentGroup: Group | null;
  leaderboard: GroupMember[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchGroups: () => Promise<void>;
  fetchGroup: (groupId: string) => Promise<void>;
  fetchLeaderboard: (groupId: string) => Promise<void>;
  createGroup: (data: CreateGroupData) => Promise<Group>;
  joinGroup: (groupId: string) => Promise<void>;
  leaveGroup: (groupId: string) => Promise<void>;
}

export interface CreateGroupData {
  name: string;
  description?: string;
  competition_type: 'daily' | 'weekly' | 'monthly';
  is_private: boolean;
}

export const useGroupsStore = create<GroupsState>((set) => ({
  groups: [],
  currentGroup: null,
  leaderboard: [],
  isLoading: false,
  error: null,

  fetchGroups: async () => {
    set({ isLoading: true, error: null });
    try {
      const groups = await groupsApi.getGroups();
      set({ groups, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchGroup: async (groupId) => {
    set({ isLoading: true, error: null });
    try {
      const group = await groupsApi.getGroup(groupId);
      set({ currentGroup: group, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  fetchLeaderboard: async (groupId) => {
    set({ isLoading: true, error: null });
    try {
      const leaderboard = await groupsApi.getLeaderboard(groupId);
      set({ leaderboard, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
    }
  },

  createGroup: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const group = await groupsApi.createGroup(data);
      set({ isLoading: false });
      return group;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  joinGroup: async (groupId) => {
    set({ isLoading: true, error: null });
    try {
      await groupsApi.joinGroup(groupId);
      set({ isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  leaveGroup: async (groupId) => {
    set({ isLoading: true, error: null });
    try {
      await groupsApi.leaveGroup(groupId);
      set({ isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },
}));
```

### 8. Create API Service Wrappers

Create `src/services/api/usersApi.ts`:

```typescript
import { supabase } from '../supabase';
import { UserProfile, UserPreferences } from '@store/userStore';

export const usersApi = {
  getCurrentUser: async (): Promise<UserProfile> => {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .single();

    if (error) throw error;
    return data;
  },

  updateProfile: async (updates: Partial<UserProfile>): Promise<UserProfile> => {
    const { data, error } = await supabase
      .from('users')
      .update(updates)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  updatePreferences: async (prefs: Partial<UserPreferences>): Promise<UserPreferences> => {
    const { data: current } = await supabase
      .from('users')
      .select('preferences')
      .single();

    const merged = { ...current?.preferences, ...prefs };

    const { data, error } = await supabase
      .from('users')
      .update({ preferences: merged })
      .select('preferences')
      .single();

    if (error) throw error;
    return data.preferences;
  },

  uploadAvatar: async (uri: string): Promise<string> => {
    // Upload to Supabase Storage
    const response = await fetch(uri);
    const blob = await response.blob();
    const fileName = `avatar-${Date.now()}.jpg`;

    const { data, error } = await supabase.storage
      .from('avatars')
      .upload(fileName, blob);

    if (error) throw error;

    const { data: publicUrl } = supabase.storage
      .from('avatars')
      .getPublicUrl(data.path);

    return publicUrl.publicUrl;
  },
};
```

Create similar API wrappers for:
- `stepsApi.ts`
- `friendsApi.ts`
- `groupsApi.ts`
- `notificationsApi.ts`

## Database Changes

None. API services consume existing backend endpoints.

## Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| zustand | ^4.x | State management |
| zustand/middleware | ^4.x | Persist middleware |

## Tests

**Store Tests**:
```typescript
describe('authStore', () => {
  it('should sign in and update state', async () => {
    const { signIn } = useAuthStore.getState();
    await signIn('test@example.com', 'password');
    expect(useAuthStore.getState().isAuthenticated).toBe(true);
  });
});
```

## Acceptance Criteria

- [ ] Zustand installed
- [ ] Auth store created with sign in/up/out methods
- [ ] User store created with profile methods
- [ ] Steps store created with tracking methods
- [ ] Friends store created with request methods
- [ ] Groups store created with join/leave methods
- [ ] API service wrappers created for all stores
- [ ] Stores properly typed with TypeScript
- [ ] Loading and error states handled
- [ ] Stores integrate with Supabase client
- [ ] Async actions return Promises

## Dependencies on Other Plans

**Requires**:
- Plan 9.1: Expo Project Initialization
- Plan 9.3: Supabase Client Configuration

**Blocks**:
- Plan 10-19: All UI screens (need stores for data)

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Store state out of sync | Refresh on screen focus |
| API errors not handled | Catch and set error state |
| Stale data | Implement refresh patterns |

## Notes

- Stores are intentionally simple and focused
- API services separate from stores for testability
- Error handling is consistent across stores
- Persistence can be added later with Zustand middleware

